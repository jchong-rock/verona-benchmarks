enum State {
    Leader,
    Follower,
    Candidate
}

enum MessageType {
    ElectionMessage
}

class Message {
    kind: MessageType;
    sender_id: U16;
    sender_state: State;
}

class Server {
    id: U16;
    mailbox: cown[Queue[Message]];
    known_servers: List[cown[Server]];
    state: cown[State] = cown.create(Follower);

    make(id: U16) {
        self.id = id;
    }

    recv(message: Message) {
        when (mailbox) {
            mailbox.push(message);
        }
    }

    broadcast(message: Message) {
        for (s in known_servers) {
            when (s) {
                s.recv(message);
            }
        }
    }

    check_mail() {
        when (mailbox) {
            if (!mailbox.isEmpty()) {
                var m = mailbox.pop();
                match (messageType) {
                    ElectionMessage => election(m);
                }
            }
        }
        check_mail();
    }

    election(m: Message) {
        match m.sender_state {
            Leader => {
                when (state) {
                    if (state != Leader) {
                        state = Follower;
                        broadcast(new Message(ElectionMessage, m.sender_id, Leader));
                    }
                    else {
                        println("Server ", id, " became leader");
                        exit(0);
                    }
                }
            }
            Candidate => {
                when (state) {
                    state = Candidate;
                    if (m.sender_id == self.id) {
                        state = Leader;
                        broadcast(new Message(ElectionMessage, m.sender_id, Leader));
                    }
                    else {
                        var highest_id = max(m.sender_id, self.id);
                        broadcast(new Message(ElectionMessage, highest_id, Candidate));
                    }
                }
            }
            _ => {
                println("Bad message");
            }
        }
    }
}

gen_x_unique_randoms(x: U16): Vec[U16] {
    var rng = rng();
    let max_val = (1 << (size_of(U16) * 8)) - 1;
    return (0..x).map(rng.gen_range(1..=max_val)).collect();
}

main() {
    let servers = 10;
    let ids = gen_x_unique_randoms(servers);
    var server_list = new Vec[cown[Server]]();
    for (i in 0..servers) {
        server_list.append(cown.create(new Server(ids[i])));
    }
    for (i in 1..servers) {
        when (server_list[i-1], server_list[i]) {
            server_list[i-1].known_servers.append(server_list[i].cown());
            server_list[i-1].check_mail();
        }
    }
    when (server_list[servers-1], server_list[0]) {
        server_list[servers-1].known_servers.append(server_list[0].cown());
        server_list[i-1].check_mail();
        server_list[i-1].recv(new Message(ElectionMessage, 0, Candidate));
    }
}